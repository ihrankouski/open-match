// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/protobuf-spec/messages.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Open Match's internal representation and wire protocol format for "MatchObjects".
// In order to request a match using the Backend API, your backend code should generate
// a new MatchObject with an ID and properties filled in (for more details about valid
// values for these fields, see the documentation).  Open Match then sends the Match
// Object through to your matchmaking function, where you add players to 'rosters' and
// store any schemaless data you wish in the 'properties' field.  The MatchObject
// is then sent, populated, out through the Backend API to your backend code.
//
// MatchObjects contain a number of fields, but many gRPC calls that take a
// MatchObject as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type MatchObject struct {
	Id         string        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string        `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Error      string        `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	Rosters    []*Roster     `protobuf:"bytes,4,rep,name=rosters" json:"rosters,omitempty"`
	Pools      []*PlayerPool `protobuf:"bytes,5,rep,name=pools" json:"pools,omitempty"`
}

func (m *MatchObject) Reset()                    { *m = MatchObject{} }
func (m *MatchObject) String() string            { return proto.CompactTextString(m) }
func (*MatchObject) ProtoMessage()               {}
func (*MatchObject) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *MatchObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MatchObject) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *MatchObject) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MatchObject) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *MatchObject) GetPools() []*PlayerPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

// Data structure to hold a list of players in a match.
type Roster struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Players []*Player `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
}

func (m *Roster) Reset()                    { *m = Roster{} }
func (m *Roster) String() string            { return proto.CompactTextString(m) }
func (*Roster) ProtoMessage()               {}
func (*Roster) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *Roster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Roster) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// A 'hard' filter to apply to the player pool.
type Filter struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Attribute string `protobuf:"bytes,2,opt,name=attribute" json:"attribute,omitempty"`
	Maxv      int64  `protobuf:"varint,3,opt,name=maxv" json:"maxv,omitempty"`
	Minv      int64  `protobuf:"varint,4,opt,name=minv" json:"minv,omitempty"`
	Stats     *Stats `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *Filter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Filter) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *Filter) GetMaxv() int64 {
	if m != nil {
		return m.Maxv
	}
	return 0
}

func (m *Filter) GetMinv() int64 {
	if m != nil {
		return m.Minv
	}
	return 0
}

func (m *Filter) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Holds statistics
type Stats struct {
	Count   int64   `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	Elapsed float64 `protobuf:"fixed64,2,opt,name=elapsed" json:"elapsed,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *Stats) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Stats) GetElapsed() float64 {
	if m != nil {
		return m.Elapsed
	}
	return 0
}

// PlayerPools are defined by a set of 'hard' filters, and can be filled in
// with the players that match those filters.
//
// PlayerPools contain a number of fields, but many gRPC calls that take a
// PlayerPool as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type PlayerPool struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Filters []*Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
	Roster  *Roster   `protobuf:"bytes,3,opt,name=roster" json:"roster,omitempty"`
	Stats   *Stats    `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *PlayerPool) Reset()                    { *m = PlayerPool{} }
func (m *PlayerPool) String() string            { return proto.CompactTextString(m) }
func (*PlayerPool) ProtoMessage()               {}
func (*PlayerPool) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{4} }

func (m *PlayerPool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerPool) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *PlayerPool) GetRoster() *Roster {
	if m != nil {
		return m.Roster
	}
	return nil
}

func (m *PlayerPool) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Open Match's internal representation and wire protocol format for "Players".
// In order to enter matchmaking using the Frontend API, your client code should generate
// a consistent (same result for each client every time they launch) with an ID and
// properties filled in (for more details about valid values for these fields,
// see the documentation).
// Players contain a number of fields, but the gRPC calls that take a
// Player as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type Player struct {
	Id         string              `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string              `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Pool       string              `protobuf:"bytes,3,opt,name=pool" json:"pool,omitempty"`
	Attributes []*Player_Attribute `protobuf:"bytes,4,rep,name=attributes" json:"attributes,omitempty"`
	Assignment string              `protobuf:"bytes,5,opt,name=assignment" json:"assignment,omitempty"`
	Status     string              `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Error      string              `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
}

func (m *Player) Reset()                    { *m = Player{} }
func (m *Player) String() string            { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()               {}
func (*Player) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{5} }

func (m *Player) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Player) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Player) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *Player) GetAttributes() []*Player_Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Player) GetAssignment() string {
	if m != nil {
		return m.Assignment
	}
	return ""
}

func (m *Player) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Player) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Player_Attribute struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *Player_Attribute) Reset()                    { *m = Player_Attribute{} }
func (m *Player_Attribute) String() string            { return proto.CompactTextString(m) }
func (*Player_Attribute) ProtoMessage()               {}
func (*Player_Attribute) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{5, 0} }

func (m *Player_Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player_Attribute) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Simple message to return success/failure and error status.
type Result struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{6} }

func (m *Result) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// IlInput is an empty message reserved for future use.
type IlInput struct {
}

func (m *IlInput) Reset()                    { *m = IlInput{} }
func (m *IlInput) String() string            { return proto.CompactTextString(m) }
func (*IlInput) ProtoMessage()               {}
func (*IlInput) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{7} }

type Assignments struct {
	Rosters    []*Roster `protobuf:"bytes,1,rep,name=rosters" json:"rosters,omitempty"`
	Assignment string    `protobuf:"bytes,10,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *Assignments) Reset()                    { *m = Assignments{} }
func (m *Assignments) String() string            { return proto.CompactTextString(m) }
func (*Assignments) ProtoMessage()               {}
func (*Assignments) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{8} }

func (m *Assignments) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *Assignments) GetAssignment() string {
	if m != nil {
		return m.Assignment
	}
	return ""
}

func init() {
	proto.RegisterType((*MatchObject)(nil), "messages.MatchObject")
	proto.RegisterType((*Roster)(nil), "messages.Roster")
	proto.RegisterType((*Filter)(nil), "messages.Filter")
	proto.RegisterType((*Stats)(nil), "messages.Stats")
	proto.RegisterType((*PlayerPool)(nil), "messages.PlayerPool")
	proto.RegisterType((*Player)(nil), "messages.Player")
	proto.RegisterType((*Player_Attribute)(nil), "messages.Player.Attribute")
	proto.RegisterType((*Result)(nil), "messages.Result")
	proto.RegisterType((*IlInput)(nil), "messages.IlInput")
	proto.RegisterType((*Assignments)(nil), "messages.Assignments")
}

func init() { proto.RegisterFile("api/protobuf-spec/messages.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 532 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x51, 0x8b, 0xd3, 0x40,
	0x10, 0x26, 0x6d, 0x93, 0x5e, 0xa7, 0xa0, 0xb2, 0x14, 0x09, 0x87, 0x48, 0x09, 0x08, 0xe5, 0xe0,
	0x1a, 0x38, 0x39, 0x4e, 0x7c, 0xab, 0x82, 0x7a, 0x0f, 0x62, 0x59, 0x9f, 0xf4, 0x6d, 0x93, 0x6e,
	0x7b, 0x2b, 0x9b, 0xec, 0xb2, 0xbb, 0x29, 0xfa, 0x13, 0x7c, 0xf0, 0x27, 0xf8, 0x0b, 0xfc, 0x93,
	0x92, 0xd9, 0xa4, 0x89, 0xf5, 0x4e, 0xb9, 0xb7, 0x9d, 0x6f, 0xbe, 0xcd, 0x7c, 0xdf, 0xcc, 0x64,
	0x61, 0xce, 0xb4, 0x48, 0xb5, 0x51, 0x4e, 0x65, 0xd5, 0xf6, 0xdc, 0x6a, 0x9e, 0xa7, 0x05, 0xb7,
	0x96, 0xed, 0xb8, 0x5d, 0x22, 0x4c, 0x4e, 0xda, 0x38, 0xf9, 0x15, 0xc0, 0xf4, 0x3d, 0x73, 0xf9,
	0xcd, 0x87, 0xec, 0x0b, 0xcf, 0x1d, 0x79, 0x00, 0x03, 0xb1, 0x89, 0x83, 0x79, 0xb0, 0x98, 0xd0,
	0x81, 0xd8, 0x90, 0xa7, 0x00, 0xda, 0x28, 0xcd, 0x8d, 0x13, 0xdc, 0xc6, 0x03, 0xc4, 0x7b, 0x08,
	0x99, 0x41, 0xc8, 0x8d, 0x51, 0x26, 0x1e, 0x62, 0xca, 0x07, 0xe4, 0x0c, 0xc6, 0x46, 0x59, 0xc7,
	0x8d, 0x8d, 0x47, 0xf3, 0xe1, 0x62, 0x7a, 0xf1, 0x68, 0x79, 0x50, 0x40, 0x31, 0x41, 0x5b, 0x02,
	0x39, 0x83, 0x50, 0x2b, 0x25, 0x6d, 0x1c, 0x22, 0x73, 0xd6, 0x31, 0xd7, 0x92, 0x7d, 0xe3, 0x66,
	0xad, 0x94, 0xa4, 0x9e, 0x92, 0xbc, 0x83, 0xc8, 0x5f, 0x27, 0x04, 0x46, 0x25, 0x2b, 0x78, 0xa3,
	0x14, 0xcf, 0x75, 0x55, 0x8d, 0x57, 0x6a, 0xa1, 0x47, 0x55, 0xfd, 0xb7, 0x68, 0x4b, 0x48, 0xbe,
	0x07, 0x10, 0xbd, 0x11, 0xf2, 0xae, 0x4f, 0x3d, 0x81, 0x09, 0x73, 0xce, 0x88, 0xac, 0x72, 0xbc,
	0x71, 0xdd, 0x01, 0xf5, 0x8d, 0x82, 0x7d, 0xdd, 0xa3, 0xe7, 0x21, 0xc5, 0x33, 0x62, 0xa2, 0xdc,
	0xc7, 0xa3, 0x06, 0x13, 0xe5, 0x9e, 0x3c, 0x83, 0xd0, 0x3a, 0xe6, 0x6a, 0x6b, 0xc1, 0x62, 0x7a,
	0xf1, 0xb0, 0x93, 0xf3, 0xb1, 0x86, 0xa9, 0xcf, 0x26, 0x57, 0x10, 0x62, 0x5c, 0x37, 0x33, 0x57,
	0x55, 0xe9, 0x50, 0xca, 0x90, 0xfa, 0x80, 0xc4, 0x30, 0xe6, 0x92, 0x69, 0xcb, 0x37, 0xa8, 0x24,
	0xa0, 0x6d, 0x98, 0xfc, 0x0c, 0x00, 0xba, 0x26, 0xdd, 0xd5, 0x93, 0x2d, 0xda, 0xbc, 0xa5, 0x27,
	0xde, 0x3f, 0x6d, 0x09, 0x64, 0x01, 0x91, 0x1f, 0x0a, 0x1a, 0xbb, 0x6d, 0x68, 0x4d, 0xbe, 0x33,
	0x36, 0xfa, 0xa7, 0xb1, 0x1f, 0x03, 0x88, 0xbc, 0xbe, 0x7b, 0xef, 0x15, 0x81, 0x51, 0x3d, 0xf2,
	0x66, 0xad, 0xf0, 0x4c, 0x5e, 0x02, 0x1c, 0x66, 0xd0, 0x2e, 0xd6, 0xe9, 0xf1, 0x88, 0x97, 0xab,
	0x96, 0x42, 0x7b, 0xec, 0xba, 0x1e, 0xb3, 0x56, 0xec, 0xca, 0x82, 0x97, 0x0e, 0xe7, 0x31, 0xa1,
	0x3d, 0x84, 0x3c, 0x86, 0xa8, 0xd6, 0x5c, 0xd9, 0x38, 0xc2, 0x5c, 0x13, 0x75, 0xfb, 0x3d, 0xee,
	0xed, 0xf7, 0xe9, 0x25, 0x4c, 0x56, 0xfd, 0x6d, 0xf8, 0xab, 0xed, 0x33, 0x08, 0xf7, 0x4c, 0x56,
	0x7e, 0x77, 0x86, 0xd4, 0x07, 0xc9, 0x0b, 0x88, 0x28, 0xb7, 0x95, 0xc4, 0x99, 0xda, 0x2a, 0xcf,
	0xb9, 0xb5, 0x78, 0xed, 0x84, 0xb6, 0x61, 0x57, 0x70, 0xd0, 0x2b, 0x98, 0x4c, 0x60, 0x7c, 0x2d,
	0xaf, 0x4b, 0x5d, 0xb9, 0xe4, 0x13, 0x4c, 0x57, 0x07, 0xdd, 0xb6, 0xff, 0xab, 0x05, 0xff, 0xfb,
	0xd5, 0xfe, 0x6c, 0x02, 0x1c, 0x37, 0xe1, 0xd5, 0xd5, 0xe7, 0xcb, 0x9d, 0x70, 0x37, 0x55, 0xb6,
	0xcc, 0x55, 0x91, 0xbe, 0x55, 0x6a, 0x27, 0xf9, 0x6b, 0xa9, 0xaa, 0xcd, 0x5a, 0x32, 0xb7, 0x55,
	0xa6, 0x48, 0x95, 0xe6, 0xe5, 0x79, 0x51, 0xbf, 0x17, 0xa9, 0x28, 0x1d, 0x37, 0x25, 0x93, 0xa9,
	0xce, 0xb2, 0x08, 0x9f, 0x95, 0xe7, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf2, 0xef, 0x26, 0x51,
	0x7a, 0x04, 0x00, 0x00,
}
